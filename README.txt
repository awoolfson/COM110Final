Auden Woolfson, COM110, final project

For this project I decided to create a basic genetic algorithm. I represented each entity with DNA as a creature called a Pyborg, and created different planets that effected the way the Pyborgs developed. Each Pyborg has a number of traits that are determined by their DNA (a string of numbers). Each planet has a number of attributes that determine how suitable each trait is for the environment. The Pyborgs are given a score based on their traits and the planets attributes, and only the highest scoring half of the Pyborgs reproduce. Reproduction involves the random combination of DNA, and assignment of new traits based on the new DNA. There is also a chance of mutation, so if a gene is not present in the population of Pyborgs, it can still become present and potentially spread.

I created a GUI to display this process, and allow the user to control it. Each Pyborg is shown with their respective traits, and the background is unique for each planet. There is a box where the user can type the name of a planet (they are listed on the left side of the screen) and change to it. There is also a randomize button for the Pyborgs so if they are homogeneous and the user wants to change the planet to see how they will evolve there, they can be reset. The reproduce button creates a new generation of Pyborgs, and the quit button closes the window.

I created two classes for this project. The first one is the pyborg class. This object takes five arguments including self. These include DNA, x, y, and window. x, y, and window tell the program where and in what window the Pyborg will be displayed. DNA is used to determine the traits of the Pyborg. The traits method takes one argument (self), and uses the DNA attribute to determine the values of each trait variable attached to the Pyborg. Traits also handles the graphics for each trait. The drawBorg method draws each trait and makes the Pyborg appear in the GUI. drawBorg also only takes the self argument. The getScore and getDNA methods are fairly self explanatory, they return the Pyborgs score and DNA. The changeDNA method is used in the reproduction process. This is necessary because the Pyborg objects are recycled through generations, so they need to get new DNA after reproduction. This method takes a list and joins it into a string, and sets it as the DNA of the Pyborg. It takes the self, and dnaList arguments, and returns the new DNA (self.dna). The scoreBorg method determines the fitness score of the Pyborg based on the traits and the planet itâ€™s on. It takes the self and pstats arguments. pstats is a list that represents each attribute the current planet has. This method contains a series of conditionals that alter the score of the Pyborg. The score is returned at the end of the method (self.score).

The other class I created is the planet class. Each planet object represents a different planet. They take the self, name, and window arguments. The name argument determines the planets name, attributes, and how it will look. This is done through conditional statements when the object is initialized. Window determines the window that the planet will be shown in. The leaveLandscape method is used when changing planets. It simply undress all of the graphics objects in the window that are attached to the planet object. The planetDesc method is used to create two strings that name and describe the planet, and returns those strings (planetDesc, planetDesc2). These are used to show the name and description of each planet in the upper left of the window. Each of the get methods only take a self argument, and do nothing but return the value that is described in their names. getStats is used to create the pstats list used in the pyborg scoreBorg method.

The program starts by initializing a graphics window, and displaying an intro message. After a mouse click, the makeDNA function is defined and used to create DNA for ten pyborg objects as they are initialized. Each of the planets are then initialized, and a function called drawDesc is created to draw the planet description in the window. This function makes use of the planetDesc method for planets, and is used immediately after it is created. Next the entry, text, and buttons are initialized. The randomize function is created for the randomize button and the complex reproduce function as well. The idea behind the reproduce function is to take the top five scoring pyborgs, and combine their DNA randomly so that they have offspring that resemble them. I also programmed in a chance of mutation. The rest of the program exists for the buttons to work. The gobtnclick function decides whether the planet entry is valid, and either displays an error message or changes the planet. This is used in the indefinite loop based around the quit button that contains conditional statements for each button. After this loop the window is closed, and the only way for that to happen is for the user to press the quit button.

For testing I made sure the traits I wanted to be favorable under certain planet conditions actually prevailed. I tested by randomizing and reproducing the population on each planet, and adjusting the scoreBorg function based on what happened. I also had to make sure each of the buttons were functional, so I tested them in different phases of the program to make sure they worked. The planet changing was where I ran into the most trouble with my tests. It was challenging to get the graphics right.  In future version of the program I would add in a selector for survival instead of only planet attributes. Maybe there could be a predator that is more effective at hunting pyborgs with certain traits, and differs from planet to planet. I could also create another window specifically for planet descriptions, so I could add more planets and have a more spacious area to use for graphics. 

The resources I used in this program are:
- graphics.py
- random.py
- buttonclass.py
- audioplayer.py
- boing2.wav from wavsource.com (https://www.wavsource.com/snds_2020-10-01_3728627494378403/sfx/boing2.wav)